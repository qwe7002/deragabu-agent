<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deragabu Agent - æµ‹è¯•å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .content {
            padding: 30px;
        }

        /* è¿æ¥é¢æ¿ */
        .connection-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            flex: 1;
        }

        .status-indicator.connected {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .status-indicator.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-indicator.connected .status-dot {
            background: #28a745;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected .status-dot {
            background: #dc3545;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        input[type="text"] {
            flex: 1;
            min-width: 250px;
            padding: 10px 15px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #f85032 0%, #e73827 100%);
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        /* ç»Ÿè®¡é¢æ¿ */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* å…‰æ ‡é¢„è§ˆåŒº */
        .cursor-preview {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .preview-header h2 {
            color: #333;
            font-size: 20px;
        }

        .scale-controls {
            display: flex;
            align-items: cen
            gap: 10px;
        }

        .scale-controls label {
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }

        .scale-controls select {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .cursor-display-area {
            background:
                repeating-linear-gradient(
                    45deg,
                    #f0f0f0 0,
                    #f0f0f0 10px,
                    #ffffff 10px,
                    #ffffff 20px
                );
            border: 3px dashed #dee2e6;
            border-radius: 8px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            position: relative;
        }

        .cursor-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .cursor-image {
            /* ä½¿ç”¨é«˜è´¨é‡çš„å›¾åƒæ¸²æŸ“ */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            /* ä½¿ç”¨ transform è€Œä¸æ˜¯ zoom ä»¥ä¿æŒæ¸…æ™°åº¦ */
            transform-origin: center;
            transition: transform 0.2s ease;
        }

        .cursor-crosshair {
            position: absolute;
            pointer-events: none;
        }

        .crosshair-h {
            position: absolute;
            height: 1px;
            width: 100%;
            background: rgba(255, 0, 0, 0.5);
            left: 0;
        }

        .crosshair-v {
            position: absolute;
            width: 1px;
            height: 100%;
            background: rgba(255, 0, 0, 0.5);
            top: 0;
        }

        .cursor-info-panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #667eea;
        }

        .cursor-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .info-item-label {
            font-size: 11px;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .info-item-value {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-success {
            background: #d4edda;
            color: #155724;
        }

        .badge-info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .badge-warning {
            background: #fff3cd;
            color: #856404;
        }

        /* æ—¥å¿— */
        .log-panel {
            background: #1e1e1e;
            border-radius: 12px;
            overflow: hidden;
        }

        .log-header {
            background: #2d2d2d;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-header h2 {
            color: #d4d4d4;
            font-size: 16px;
        }

        .log-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: #3d3d3d;
            color: #d4d4d4;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .log-content {
            padding: 15px 20px;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .log-entry {
            margin: 3px 0;
            color: #d4d4d4;
        }

        .log-entry .timestamp {
            color: #858585;
        }

        .log-entry.info { color: #4ec9b0; }
        .log-entry.warn { color: #dcdcaa; }
        .log-entry.error { color: #f48771; }

        .empty-state {
            text-align: center;
            color: #adb5bd;
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* åŠ¨ç”»å…‰æ ‡é¢æ¿ */
        .animation-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .animation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .animation-header h2 {
            color: #333;
            font-size: 20px;
        }

        .animation-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
        }

        .animation-status.detecting {
            background: #fff3cd;
            color: #856404;
        }

        .animation-status.active {
            background: #d4edda;
            color: #155724;
        }

        .animation-status.idle {
            background: #e2e3e5;
            color: #383d41;
        }

        .animation-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .animation-controls button {
            padding: 8px 16px;
            font-size: 13px;
        }

        .animation-controls .speed-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .animation-controls .speed-control label {
            font-size: 13px;
            font-weight: 600;
            color: #666;
        }

        .animation-controls .speed-control select {
            padding: 6px 10px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 13px;
        }

        .animation-playback {
            background: white;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .animation-preview {
            background:
                repeating-linear-gradient(
                    45deg,
                    #f0f0f0 0, #f0f0f0 10px,
                    #ffffff 10px, #ffffff 20px
                );
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .animation-preview img {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .animation-meta {
            flex: 1;
        }

        .animation-progress {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .animation-progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 3px;
            transition: width 0.1s ease;
        }

        .filmstrip-container {
            background: white;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            padding: 15px;
        }

        .filmstrip-label {
            font-size: 12px;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .filmstrip {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 8px 0;
        }

        .filmstrip-frame {
            flex-shrink: 0;
            background:
                repeating-linear-gradient(
                    45deg,
                    #f8f8f8 0, #f8f8f8 5px,
                    #fff 5px, #fff 10px
                );
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            min-width: 60px;
        }

        .filmstrip-frame:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .filmstrip-frame.active {
            border-color: #764ba2;
            box-shadow: 0 0 0 2px rgba(118, 75, 162, 0.3);
        }

        .filmstrip-frame img {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            display: block;
            margin: 0 auto 4px;
        }

        .filmstrip-frame .frame-label {
            font-size: 10px;
            color: #999;
            font-weight: 600;
        }

        .animation-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .anim-stat {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .anim-stat .stat-label {
            font-size: 10px;
        }

        .anim-stat .stat-value {
            font-size: 20px;
        }

        /* å‰ªè²¼æ¿åŒæ­¥é¢æ¿ */
        .clipboard-panel {
            background: #f0f4ff;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid #d0d8ff;
        }

        .clipboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .clipboard-header h2 { color: #333; font-size: 20px; }

        .clipboard-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .clipboard-preview {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 16px;
            min-height: 80px;
            font-family: monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-break: break-all;
            color: #333;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }

        .clipboard-preview img {
            max-width: 100%;
            max-height: 160px;
            border-radius: 4px;
        }

        .clipboard-meta {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        .clipboard-direction {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .dir-from-host { background: #d1ecf1; color: #0c5460; }
        .dir-from-client { background: #d4edda; color: #155724; }

        .file-notice {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 13px;
            color: #856404;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ–±ï¸ Deragabu Agent</h1>
            <p>é«˜æ¸…æ™°åº¦å…‰æ ‡æ•è· Â· å‰ªè²¼æ¿åŒæ­¥</p>
        </div>

        <div class="content">
            <!-- è¿æ¥æ§åˆ¶ -->
            <div class="connection-panel">
                <div class="status-bar">
                    <div id="statusIndicator" class="status-indicator disconnected">
                        <div class="status-dot"></div>
                        <span id="statusText">æœªè¿æ¥</span>
                    </div>
                </div>

                <div class="controls">
                    <input type="text" id="wsUrl" value="http://127.0.0.1:9000" placeholder="http://host:port">
                    <button id="connectBtn" class="btn-primary" onclick="connect()">è¿æ¥</button>
                    <button id="disconnectBtn" class="btn-danger" onclick="disconnect()" disabled>æ–­å¼€</button>
                    <button class="btn-secondary" onclick="clearLog()">æ¸…é™¤æ—¥å¿—</button>
                </div>
            </div>

            <!-- ç»Ÿè®¡ -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">æ¶ˆæ¯æ•°</div>
                    <div class="stat-value" id="messageCount">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">å…‰æ ‡æ›´æ–°</div>
                    <div class="stat-value" id="cursorUpdateCount">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">æ•°æ®é‡</div>
                    <div class="stat-value" id="totalBytes">0 KB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">FPS</div>
                    <div class="stat-value" id="fps">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ç¼“å­˜å‘½ä¸­</div>
                    <div class="stat-value" id="cacheHitRate">0%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ç¼“å­˜æ•°</div>
                    <div class="stat-value" id="cacheSize">0</div>
                </div>
            </div>

            <!-- å…‰æ ‡é¢„è§ˆ -->
            <div class="cursor-preview">
                <div class="preview-header">
                    <h2>ğŸ“ å…‰æ ‡é¢„è§ˆ</h2>
                    <div class="scale-controls">
                        <label for="scaleSelect">é¢„è§ˆç¼©æ”¾:</label>
                        <select id="scaleSelect" onchange="updateScale()">
                            <option value="1">100% (åŸå§‹å¤§å°)</option>
                            <option value="2" selected>200% (2x)</option>
                            <option value="3">300% (3x)</option>
                            <option value="4">400% (4x)</option>
                            <option value="0.5">50% (ç¼©å°)</option>
                        </select>
                        <label for="dprSelect" style="margin-left: 15px;">å®¢æˆ·ç«¯ DPR:</label>
                        <select id="dprSelect" onchange="updateDPR()">
                            <option value="auto" selected>è‡ªåŠ¨ (å½“å‰: Ã—1)</option>
                            <option value="1">1.0</option>
                            <option value="1.25">1.25</option>
                            <option value="1.5">1.5</option>
                            <option value="2">2.0</option>
                            <option value="3">3.0</option>
                        </select>
                        <label>
                            <input type="checkbox" id="showCrosshair" onchange="toggleCrosshair()">
                            æ˜¾ç¤ºåå­—çº¿
                        </label>
                    </div>
                </div>

                <div class="cursor-display-area" id="cursorDisplay">
                    <div class="empty-state">
                        <div class="icon">ğŸ–±ï¸</div>
                        <div>ç­‰å¾…å…‰æ ‡æ•°æ®...</div>
                    </div>
                </div>

                <div class="cursor-info-panel" id="cursorInfoPanel" style="display: none;">
                    <div class="cursor-info-grid" id="cursorInfo"></div>
                </div>
            </div>

            <!-- åŠ¨ç”»å…‰æ ‡æµ‹è¯• -->
            <div class="animation-panel" id="animationPanel">
                <div class="animation-header">
                    <h2>ğŸ¬ å‹•ç•«å…‰æ¨™æ¸¬è©¦</h2>
                    <div class="animation-status idle" id="animStatus">
                        <span id="animStatusText">ç­‰å¾…æ£€æµ‹</span>
                    </div>
                </div>

                <div class="animation-controls">
                    <button class="btn-primary" id="animPlayPauseBtn" onclick="toggleAnimPlayback()" disabled>â–¶ æ’­æ”¾</button>
                    <button class="btn-secondary" onclick="resetAnimFrames()">ğŸ—‘ æ¸…é™¤å¸§</button>
                    <button class="btn-secondary" onclick="captureAnimSnapshot()">ğŸ“¸ å¿«ç…§</button>
                    <div class="speed-control">
                        <label for="animSpeedSelect">æ’­æ”¾é€Ÿåº¦:</label>
                        <select id="animSpeedSelect" onchange="updateAnimSpeed()">
                            <option value="0.25">0.25x</option>
                            <option value="0.5">0.5x</option>
                            <option value="1" selected>1x</option>
                            <option value="2">2x</option>
                            <option value="4">4x</option>
                        </select>
                    </div>
                    <div class="speed-control">
                        <label>æ£€æµ‹é˜ˆå€¼:</label>
                        <select id="animThreshold" onchange="updateAnimThreshold()">
                            <option value="3">3 å¸§ (çµæ•)</option>
                            <option value="5" selected>5 å¸§</option>
                            <option value="8">8 å¸§</option>
                            <option value="12">12 å¸§ (å®½æ¾)</option>
                        </select>
                    </div>
                </div>

                <div class="animation-playback" id="animPlayback" style="display: none;">
                    <div class="animation-preview" id="animPreview">
                        <div class="empty-state"><div class="icon" style="font-size:32px">ğŸ–±ï¸</div></div>
                    </div>
                    <div class="animation-meta">
                        <div style="font-size: 14px; font-weight: 600; color: #333;">
                            å¸§: <span id="animCurrentFrame">0</span> / <span id="animTotalFrames">0</span>
                            &nbsp;&nbsp;|&nbsp;&nbsp;
                            å¾ªç¯: <span class="badge badge-info" id="animCycleStatus">æ£€æµ‹ä¸­</span>
                        </div>
                        <div class="animation-progress">
                            <div class="animation-progress-bar" id="animProgressBar" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div class="filmstrip-container">
                    <div class="filmstrip-label">å¸§åºåˆ— (æ—¶é—´é¡ºåº)</div>
                    <div class="filmstrip" id="filmstrip">
                        <div class="empty-state" style="width: 100%; padding: 20px;">
                            <div>ç­‰å¾…åŠ¨ç”»å…‰æ ‡æ•°æ®...</div>
                        </div>
                    </div>
                </div>

                <div class="animation-stats-grid">
                    <div class="anim-stat">
                        <div class="stat-label">å¸§æ•°</div>
                        <div class="stat-value" id="animFrameCount">0</div>
                    </div>
                    <div class="anim-stat">
                        <div class="stat-label">å”¯ä¸€å¸§</div>
                        <div class="stat-value" id="animUniqueFrames">0</div>
                    </div>
                    <div class="anim-stat">
                        <div class="stat-label">å¸§ç‡</div>
                        <div class="stat-value" id="animFps">0</div>
                    </div>
                    <div class="anim-stat">
                        <div class="stat-label">å¾ªç¯å‘¨æœŸ</div>
                        <div class="stat-value" id="animCyclePeriod">-</div>
                    </div>
                    <div class="anim-stat">
                        <div class="stat-label">å¾ªç¯æ¬¡æ•°</div>
                        <div class="stat-value" id="animCycleCount">0</div>
                    </div>
                </div>
            </div>

            <!-- å‰ªè²¼æ¿åŒæ­¥ -->
            <div class="clipboard-panel">
                <div class="clipboard-header">
                    <h2>ğŸ“‹ å‰ªè²¼æ¿åŒæ­¥</h2>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <label style="font-size:13px;font-weight:600;cursor:pointer;">
                            <input type="checkbox" id="clipAutoSync" onchange="toggleClipAutoSync()"> è‡ªå‹•åŒæ­¥
                        </label>
                    </div>
                </div>

                <div class="clipboard-controls">
                    <button class="btn-primary" onclick="pushClipboardToHost()">â¬†ï¸ æ¨é€åˆ°ä¸»æ©Ÿ</button>
                    <button class="btn-secondary" onclick="clearClipboardPreview()">ğŸ—‘ æ¸…é™¤é è¦½</button>
                </div>

                <!-- Last received from host -->
                <div style="margin-bottom:12px;">
                    <div style="font-size:12px;font-weight:600;color:#6c757d;text-transform:uppercase;margin-bottom:6px;">
                        æœ€å¾Œæ”¶åˆ°ï¼ˆä¸»æ©Ÿ â†’ å®¢æˆ¶ç«¯ï¼‰
                        <span id="clipFromHostDir" class="clipboard-direction dir-from-host" style="display:none;">â¬‡ï¸ ä¸»æ©Ÿ</span>
                    </div>
                    <div class="clipboard-preview" id="clipFromHostPreview">
                        <span style="color:#aaa;">ç­‰å¾…ä¸»æ©Ÿå‰ªè²¼æ¿æ•¸æ“šâ€¦</span>
                    </div>
                    <div class="clipboard-meta" id="clipFromHostMeta"></div>
                </div>

                <!-- File transfer notice (stub) -->
                <div class="file-notice" id="clipFileNotice" style="display:none;">
                    ğŸ“ <strong>æ–‡ä»¶å‚³è¼¸å°šæœªå¯¦ç¾</strong> â€”
                    æ–‡ä»¶åç¨±: <span id="clipFileNames"></span>ã€‚
                    æœªä¾†ç‰ˆæœ¬å°‡æ”¯æŒåˆ†å¡Šå‚³è¼¸ã€‚
                </div>

                <!-- Stats row -->
                <div style="display:flex;gap:20px;flex-wrap:wrap;margin-top:10px;">
                    <div class="stat-card" style="min-width:120px;">
                        <div class="stat-label">å·²æ¥æ”¶</div>
                        <div class="stat-value" id="clipRecvCount">0</div>
                    </div>
                    <div class="stat-card" style="min-width:120px;">
                        <div class="stat-label">å·²æ¨é€</div>
                        <div class="stat-value" id="clipSentCount">0</div>
                    </div>
                    <div class="stat-card" style="min-width:160px;">
                        <div class="stat-label">ä¸Šæ¬¡åŒæ­¥</div>
                        <div class="stat-value" style="font-size:14px;" id="clipLastSync">â€”</div>
                    </div>
                </div>
            </div>

            <!-- æ—¥å¿— -->
            <div class="log-panel">
                <div class="log-header">
                    <h2>ğŸ“‹ æ—¥å¿—</h2>
                    <button class="log-btn" onclick="clearLog()">æ¸…é™¤</button>
                </div>
                <div class="log-content" id="log"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/protobufjs@7/dist/protobuf.min.js"></script>
    <script>
        let pc = null;   // RTCPeerConnection
        let dc = null;   // RTCDataChannel
        let messageCount = 0;
        let cursorUpdateCount = 0;
        let totalBytes = 0;
        let fpsCounter = 0;
        let currentScale = 2;
        let showCrosshair = false;

        let CursorMessage = null;
        let MessageType = null;
        let ClipboardContentType = null;
        let ClipboardData = null;

        const cursorCache = new Map();
        let cacheHits = 0;
        let cacheMisses = 0;
        let currentCursorId = null;

        // --- åŠ¨ç”»å…‰æ ‡æ£€æµ‹ ---
        const animFrameSequence = [];       // æŒ‰æ—¶é—´é¡ºåºçš„ cursor_id åˆ—è¡¨
        const animFrameTimestamps = [];     // å¸§æ¥æ”¶æ—¶é—´æˆ³
        const animUniqueCursors = new Map(); // cursor_id -> {url, info}
        let animDetected = false;
        let animPlaying = false;
        let animPlayTimer = null;
        let animPlayIndex = 0;
        let animPlaySpeed = 1.0;
        let animThreshold = 5;             // æ£€æµ‹é˜ˆå€¼: å¤šå°‘ä¸ªä¸åŒcursor_idæ‰ç®—åŠ¨ç”»
        let animCycleLength = 0;
        let animCycleCount = 0;
        let animLastChangeTime = 0;
        let animFrameIntervals = [];       // å¸§é—´éš”(ms)åˆ—è¡¨

        // å‰ªè²¼æ¿åŒæ­¥
        let clipRecvCount = 0;
        let clipSentCount = 0;
        let clipAutoSync = false;
        let clipAutoSyncTimer = null;

        window.addEventListener('load', async () => {
            await initProtobuf();
            startFPSCounter();
            // Update auto DPR label
            const dpr = window.devicePixelRatio || 1;
            const autoOption = document.querySelector('#dprSelect option[value="auto"]');
            if (autoOption) autoOption.textContent = `è‡ªåŠ¨ (å½“å‰: Ã—${dpr})`;
            log('âœ… æµ‹è¯•å·¥å…·å·²å°±ç»ª', 'info');
        });

        async function initProtobuf() {
            // Build candidate URLs: relative (works when served by agent),
            // then absolute from the configured server address (works when
            // opened as a local file), then a bundled fallback.
            const serverBase = document.getElementById('wsUrl').value.trim().replace(/\/$/, '');
            const candidates = ['/proto', `${serverBase}/proto`];

            let protoText = null;
            for (const url of candidates) {
                try {
                    const resp = await fetch(url);
                    if (resp.ok) { protoText = await resp.text(); break; }
                } catch (_) { /* try next */ }
            }

            // â”€â”€ bundled fallback (mirrors proto/cursor.proto exactly) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (!protoText) {
                log('âš ï¸ ç„¡æ³•å¾æœå‹™å™¨ç²å– protoï¼Œä½¿ç”¨å…§å»ºå®šç¾©', 'warn');
                protoText = `syntax = "proto3";
package cursor;
message CursorMessage {
    MessageType type = 1;
    oneof payload {
        CursorData cursor_data = 2;
        CursorSignal cursor_signal = 3;
        ClipboardData clipboard_data = 5;
    }
    uint64 timestamp = 4;
}
message CursorData {
    string cursor_id = 1;
    bytes image_data = 2;
    int32 width = 3;
    int32 height = 4;
    int32 hotspot_x = 5;
    int32 hotspot_y = 6;
    float dpi_scale = 7;
    bool is_animated = 8;
    uint32 frame_delay_ms = 9;
}
message CursorSignal {
    string cursor_id = 1;
}
message ClipboardData {
    ClipboardContentType content_type = 1;
    bytes payload = 2;
    string content_hash = 3;
    repeated string filenames = 4;
    repeated uint64 file_sizes = 5;
}
enum ClipboardContentType {
    CLIPBOARD_CONTENT_TYPE_UNSPECIFIED = 0;
    CLIPBOARD_CONTENT_TYPE_TEXT = 1;
    CLIPBOARD_CONTENT_TYPE_IMAGE = 2;
    CLIPBOARD_CONTENT_TYPE_FILES = 3;
}
enum MessageType {
    MESSAGE_TYPE_UNSPECIFIED = 0;
    MESSAGE_TYPE_CURSOR_DATA = 1;
    MESSAGE_TYPE_CURSOR_SIGNAL = 2;
    MESSAGE_TYPE_CURSOR_HIDE = 3;
    MESSAGE_TYPE_HEARTBEAT = 4;
    MESSAGE_TYPE_CLIPBOARD = 5;
}`;
            }
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            try {
                const root = protobuf.parse(protoText, { keepCase: true }).root;
                CursorMessage = root.lookupType('cursor.CursorMessage');
                MessageType = root.lookupEnum('cursor.MessageType').values;
                ClipboardContentType = root.lookupEnum('cursor.ClipboardContentType').values;
                ClipboardData = root.lookupType('cursor.ClipboardData');
                log('âœ… Protobuf å·²åŠ è¼‰', 'info');
            } catch (e) {
                log('âŒ Protobuf è§£æå¤±æ•—: ' + e.message, 'error');
            }
        }

        function startFPSCounter() {
            setInterval(() => {
                document.getElementById('fps').textContent = fpsCounter;
                fpsCounter = 0;
            }, 1000);
        }

        async function connect() {
            if (!CursorMessage) {
                log('âŒ Protobuf æœªåˆå§‹åŒ–', 'error');
                return;
            }

            const baseUrl = document.getElementById('wsUrl').value.trim().replace(/\/$/, '');
            log(`ğŸ”Œ å»ºç«‹ WebRTC é€£æ¥: ${baseUrl}â€¦`, 'info');
            updateStatus('connecting');
            document.getElementById('connectBtn').disabled = true;

            try {
                pc = new RTCPeerConnection({ iceServers: [] });

                // Create DataChannel (client is the offerer, so it creates the channel)
                dc = pc.createDataChannel('deragabu');
                dc.binaryType = 'arraybuffer';

                dc.onopen = () => {
                    log('âœ… DataChannel å·²é–‹å•Ÿ', 'info');
                    updateStatus('connected');
                    document.getElementById('disconnectBtn').disabled = false;

                    // Send client DPR
                    const dpr = window.devicePixelRatio || 1;
                    const config = JSON.stringify({ device_pixel_ratio: dpr });
                    dc.send(config);
                    log(`ğŸ“ ç™¼é€ DPR: ${dpr}`, 'info');
                };

                dc.onclose = () => {
                    log('âš ï¸ DataChannel å·²é—œé–‰', 'warn');
                    updateStatus('disconnected');
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                };

                dc.onerror = (e) => {
                    log('âŒ DataChannel éŒ¯èª¤: ' + (e.message || ''), 'error');
                };

                dc.onmessage = handleMessage;

                // Create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                // Wait for ICE gathering (with 3s timeout)
                await new Promise(resolve => {
                    if (pc.iceGatheringState === 'complete') { resolve(); return; }
                    const check = () => { if (pc.iceGatheringState === 'complete') resolve(); };
                    pc.addEventListener('icegatheringstatechange', check);
                    setTimeout(resolve, 3000);
                });

                const resp = await fetch(`${baseUrl}/offer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sdp: pc.localDescription.sdp, type: 'offer' })
                });

                if (!resp.ok) {
                    throw new Error(`Offer rejected: ${resp.status} ${resp.statusText}`);
                }

                const answer = await resp.json();
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                log('ğŸ¤ SDP äº¤æ›å®Œæˆï¼Œç­‰å¾… DataChannelâ€¦', 'info');

            } catch (e) {
                log('âŒ é€£æ¥å¤±æ•—: ' + e.message, 'error');
                updateStatus('disconnected');
                document.getElementById('connectBtn').disabled = false;
                if (pc) { pc.close(); pc = null; dc = null; }
            }
        }

        function disconnect() {
            if (dc) { dc.close(); dc = null; }
            if (pc) { pc.close(); pc = null; }
            stopClipAutoSync();
        }

        function handleMessage(event) {
            try {
                const data = new Uint8Array(event.data);
                const message = CursorMessage.decode(data);

                messageCount++;
                totalBytes += data.length;

                updateStats();
                handleCursorMessage(message);
            } catch (e) {
                log('âŒ è§£æå¤±è´¥: ' + e.message, 'error');
            }
        }

        function handleCursorMessage(message) {
            if (message.type === 1) { // CURSOR_DATA - new cursor image scaled for this client
                cursorUpdateCount++;
                fpsCounter++;
                cacheMisses++;

                const data = message.cursor_data;
                if (!data) {
                    log('âš ï¸ CURSOR_DATA ç¼ºå°‘ cursor_data', 'warn');
                    return;
                }

                const dataSize = data.image_data.length;
                const blob = new Blob([data.image_data], { type: 'image/webp' });
                const imageUrl = URL.createObjectURL(blob);

                // Clean up old cache entry
                const old = cursorCache.get(data.cursor_id);
                if (old && old.url) URL.revokeObjectURL(old.url);

                cursorCache.set(data.cursor_id, {
                    url: imageUrl,
                    hotspot_x: data.hotspot_x,
                    hotspot_y: data.hotspot_y,
                    width: data.width,
                    height: data.height,
                    dpi_scale: data.dpi_scale,
                    is_animated: data.is_animated || false,
                    frame_delay_ms: data.frame_delay_ms || 0
                });

                // LRU: limit 100 (increased for animated cursors with many frames)
                if (cursorCache.size > 100) {
                    const firstKey = cursorCache.keys().next().value;
                    const cached = cursorCache.get(firstKey);
                    if (cached && cached.url) URL.revokeObjectURL(cached.url);
                    cursorCache.delete(firstKey);
                }

                currentCursorId = data.cursor_id;
                displayCursor(imageUrl, data, true, dataSize);
                trackAnimFrame(data.cursor_id, data.is_animated, data.frame_delay_ms);
                const animTag = data.is_animated ? `, ğŸ¬åŠ¨ç”» delay=${data.frame_delay_ms}ms` : '';
                log(`ğŸ“¦ æ–°å…‰æ ‡: ${data.cursor_id.substring(0, 12)}... (${data.width}x${data.height}, dpi=${data.dpi_scale.toFixed(2)}, ${(dataSize/1024).toFixed(1)}KB${animTag})`, 'info');

            } else if (message.type === 2) { // CURSOR_SIGNAL - switch to cached cursor
                cursorUpdateCount++;
                fpsCounter++;
                cacheHits++;

                const signal = message.cursor_signal;
                if (!signal) {
                    log('âš ï¸ CURSOR_SIGNAL ç¼ºå°‘ cursor_signal', 'warn');
                    return;
                }

                const cached = cursorCache.get(signal.cursor_id);
                if (cached) {
                    currentCursorId = signal.cursor_id;
                    displayCursor(cached.url, cached, false, 0);
                    trackAnimFrame(signal.cursor_id, cached.is_animated, cached.frame_delay_ms);
                } else {
                    log('âš ï¸ ä¿¡å·å¼•ç”¨æœªçŸ¥å…‰æ ‡: ' + signal.cursor_id, 'warn');
                }

            } else if (message.type === 3) { // CURSOR_HIDE
                hideCursor();
            } else if (message.type === 4) { // HEARTBEAT
                log('ğŸ’“ å¿ƒè·³', 'info');
            } else if (message.type === 5) { // CLIPBOARD
                handleClipboardMessage(message);
            }
        }

        function displayCursor(imageUrl, cursorInfo, isFull, dataSize) {
            const display = document.getElementById('cursorDisplay');
            const dpr = cursorInfo.dpi_scale || window.devicePixelRatio || 1;

            // The server already scaled the image for our DPR.
            // Display at CSS size = pixel size / DPR for pixel-perfect rendering.
            const cssWidth = cursorInfo.width / dpr;
            const cssHeight = cursorInfo.height / dpr;
            const hotspotX = cursorInfo.hotspot_x / dpr;
            const hotspotY = cursorInfo.hotspot_y / dpr;

            let html = `
                <div class="cursor-wrapper">
                    <img src="${imageUrl}"
                         class="cursor-image"
                         alt="cursor"
                         width="${cssWidth * currentScale}"
                         height="${cssHeight * currentScale}"
                         style="max-width: none; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges;">
            `;

            if (showCrosshair) {
                html += `
                    <div class="cursor-crosshair" style="left: ${hotspotX * currentScale}px; top: ${hotspotY * currentScale}px;">
                        <div class="crosshair-h"></div>
                        <div class="crosshair-v"></div>
                    </div>
                `;
            }

            html += '</div>';
            display.innerHTML = html;

            // Show info panel
            const panel = document.getElementById('cursorInfoPanel');
            const info = document.getElementById('cursorInfo');
            panel.style.display = 'block';

            info.innerHTML = `
                <div>
                    <div class="info-item-label">å›¾åƒå°ºå¯¸</div>
                    <div class="info-item-value">${cursorInfo.width} Ã— ${cursorInfo.height} px</div>
                </div>
                <div>
                    <div class="info-item-label">CSS å°ºå¯¸</div>
                    <div class="info-item-value">${cssWidth.toFixed(0)} Ã— ${cssHeight.toFixed(0)} px</div>
                </div>
                <div>
                    <div class="info-item-label">çƒ­ç‚¹</div>
                    <div class="info-item-value">(${cursorInfo.hotspot_x}, ${cursorInfo.hotspot_y})</div>
                </div>
                <div>
                    <div class="info-item-label">DPI ç¼©æ”¾</div>
                    <div class="info-item-value"><span class="badge badge-info">${dpr.toFixed(2)}</span></div>
                </div>
                <div>
                    <div class="info-item-label">çŠ¶æ€</div>
                    <div class="info-item-value">
                        <span class="badge ${isFull ? 'badge-warning' : 'badge-success'}">
                            ${isFull ? 'å®Œæ•´æ•°æ®' : 'ä¿¡å·åˆ‡æ¢'}
                        </span>
                    </div>
                </div>
                <div>
                    <div class="info-item-label">å¤§å°</div>
                    <div class="info-item-value">${dataSize > 0 ? (dataSize/1024).toFixed(2) + ' KB' : '-'}</div>
                </div>
            `;
        }

        function hideCursor() {
            document.getElementById('cursorDisplay').innerHTML = `
                <div class="empty-state">
                    <div class="icon">ğŸ‘»</div>
                    <div>å…‰æ ‡å·²éšè—</div>
                </div>
            `;
            document.getElementById('cursorInfoPanel').style.display = 'none';
        }

        function updateScale() {
            currentScale = parseFloat(document.getElementById('scaleSelect').value);
            log(`ğŸ” é¢„è§ˆç¼©æ”¾: ${currentScale * 100}%`, 'info');
            // Re-render current cursor if any
            if (currentCursorId) {
                const cached = cursorCache.get(currentCursorId);
                if (cached) {
                    displayCursor(cached.url, cached, false, 0);
                }
            }
        }

        function updateDPR() {
            const select = document.getElementById('dprSelect');
            let dpr;
            if (select.value === 'auto') {
                dpr = window.devicePixelRatio || 1;
            } else {
                dpr = parseFloat(select.value);
            }
            if (dc && dc.readyState === 'open') {
                const config = JSON.stringify({ device_pixel_ratio: dpr });
                dc.send(config);
                log(`ğŸ“ æ›´æ–° DPR: ${dpr}`, 'info');
            } else {
                log('âš ï¸ æœªè¿æ¥ï¼Œæ— æ³•æ›´æ–° DPR', 'warn');
            }
        }

        function toggleCrosshair() {
            showCrosshair = document.getElementById('showCrosshair').checked;
            log(`${showCrosshair ? 'âœ…' : 'âŒ'} åå­—çº¿: ${showCrosshair ? 'å¼€å¯' : 'å…³é—­'}`, 'info');
        }

        function updateStats() {
            document.getElementById('messageCount').textContent = messageCount;
            document.getElementById('cursorUpdateCount').textContent = cursorUpdateCount;

            const kb = totalBytes / 1024;
            document.getElementById('totalBytes').textContent =
                kb < 1024 ? kb.toFixed(2) + ' KB' : (kb/1024).toFixed(2) + ' MB';

            const total = cacheHits + cacheMisses;
            const hitRate = total > 0 ? (cacheHits / total * 100).toFixed(1) : 0;
            document.getElementById('cacheHitRate').textContent = hitRate + '%';

            document.getElementById('cacheSize').textContent = cursorCache.size;
        }

        function updateStatus(state) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            indicator.className = 'status-indicator ' + state;
            text.textContent = state === 'connected' ? 'å·²è¿æ¥' :
                              state === 'connecting' ? 'è¿æ¥ä¸­...' : 'æœªè¿æ¥';
        }

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        // ========== å‰ªè²¼æ¿åŒæ­¥åŠŸèƒ½ ==========

        function handleClipboardMessage(message) {
            const clip = message.clipboard_data;
            if (!clip) { log('âš ï¸ CLIPBOARD æ¶ˆæ¯ç¼ºå°‘ clipboard_data', 'warn'); return; }

            clipRecvCount++;
            document.getElementById('clipRecvCount').textContent = clipRecvCount;
            document.getElementById('clipLastSync').textContent = new Date().toLocaleTimeString();

            const previewEl = document.getElementById('clipFromHostPreview');
            const metaEl   = document.getElementById('clipFromHostMeta');
            const dirEl    = document.getElementById('clipFromHostDir');
            dirEl.style.display = 'inline-flex';

            const ct = clip.content_type; // numeric from protobufjs

            // CLIPBOARD_CONTENT_TYPE_TEXT = 1
            if (ct === 1) {
                const text = new TextDecoder().decode(clip.payload);
                previewEl.textContent = text;
                metaEl.textContent = `æ–‡æœ¬ Â· ${text.length} å­—ç¬¦ Â· hash: ${clip.content_hash.substring(0, 8)}â€¦`;
                log(`ğŸ“‹ æ”¶åˆ°æ–‡æœ¬å‰ªè²¼æ¿ (${text.length} å­—ç¬¦)`, 'info');

                // Write to browser clipboard (requires secure context + user gesture previously granted)
                navigator.clipboard.writeText(text).catch(() => {});

            // CLIPBOARD_CONTENT_TYPE_IMAGE = 2
            } else if (ct === 2) {
                const blob = new Blob([clip.payload], { type: 'image/png' });
                const url  = URL.createObjectURL(blob);
                previewEl.innerHTML = `<img src="${url}" onload="URL.revokeObjectURL('${url}')">`;
                const kb = (clip.payload.length / 1024).toFixed(1);
                metaEl.textContent = `åœ–ç‰‡ PNG Â· ${kb} KB Â· hash: ${clip.content_hash.substring(0, 8)}â€¦`;
                log(`ğŸ–¼ï¸ æ”¶åˆ°åœ–ç‰‡å‰ªè²¼æ¿ (${kb} KB)`, 'info');

                // Write PNG to browser clipboard via ClipboardItem
                if (window.ClipboardItem) {
                    const cbBlob = new Blob([clip.payload], { type: 'image/png' });
                    navigator.clipboard.write([new ClipboardItem({ 'image/png': cbBlob })]).catch(() => {});
                }

            // CLIPBOARD_CONTENT_TYPE_FILES = 3
            } else if (ct === 3) {
                const names = clip.filenames || [];
                previewEl.innerHTML = `<span style="color:#888;">[æ–‡ä»¶åˆ—è¡¨ â€” å‚³è¼¸å°šæœªå¯¦ç¾]</span>`;
                metaEl.textContent = `${names.length} å€‹æ–‡ä»¶`;
                document.getElementById('clipFileNotice').style.display = 'block';
                document.getElementById('clipFileNames').textContent = names.join(', ') || '(ç©º)';
                log(`ğŸ“ æ”¶åˆ°æ–‡ä»¶å‰ªè²¼æ¿ (${names.length} å€‹æ–‡ä»¶) â€” å‚³è¼¸æœªå¯¦ç¾`, 'warn');
            }
        }

        /** å°‡ç€è¦½å™¨ç•¶å‰å‰ªè²¼æ¿æ¨é€åˆ°ä¸»æ©Ÿï¼ˆéœ€è¦ HTTPS æˆ– localhostï¼‰*/
        async function pushClipboardToHost() {
            if (!dc || dc.readyState !== 'open') {
                log('âš ï¸ æœªé€£æ¥ï¼Œç„¡æ³•æ¨é€å‰ªè²¼æ¿', 'warn');
                return;
            }
            if (!CursorMessage || !ClipboardData) {
                log('âŒ Protobuf æœªåˆå§‹åŒ–', 'error');
                return;
            }

            try {
                // Try reading clipboard items (image first, then text)
                let sent = false;

                if (window.ClipboardItem) {
                    try {
                        const items = await navigator.clipboard.read();
                        for (const item of items) {
                            if (item.types.includes('image/png')) {
                                const blob   = await item.getType('image/png');
                                const arrBuf = await blob.arrayBuffer();
                                const bytes  = new Uint8Array(arrBuf);
                                const hash   = await sha256hex(bytes);
                                sendClipboardProto(2 /* IMAGE */, bytes, hash, [], []);
                                sent = true;
                                clipSentCount++;
                                document.getElementById('clipSentCount').textContent = clipSentCount;
                                document.getElementById('clipLastSync').textContent = new Date().toLocaleTimeString();
                                log(`â¬†ï¸ æ¨é€åœ–ç‰‡åˆ°ä¸»æ©Ÿ (${(bytes.length/1024).toFixed(1)} KB)`, 'info');
                                break;
                            }
                        }
                    } catch (_) { /* read() may fail without HTTPS */ }
                }

                if (!sent) {
                    const text = await navigator.clipboard.readText();
                    if (text) {
                        const bytes = new TextEncoder().encode(text);
                        const hash  = await sha256hex(bytes);
                        sendClipboardProto(1 /* TEXT */, bytes, hash, [], []);
                        clipSentCount++;
                        document.getElementById('clipSentCount').textContent = clipSentCount;
                        document.getElementById('clipLastSync').textContent = new Date().toLocaleTimeString();
                        log(`â¬†ï¸ æ¨é€æ–‡æœ¬åˆ°ä¸»æ©Ÿ (${text.length} å­—ç¬¦)`, 'info');
                    } else {
                        log('âš ï¸ ç€è¦½å™¨å‰ªè²¼æ¿ç‚ºç©º', 'warn');
                    }
                }
            } catch (e) {
                log('âŒ è®€å–ç€è¦½å™¨å‰ªè²¼æ¿å¤±æ•—: ' + e.message + ' (éœ€è¦å®‰å…¨ç’°å¢ƒæˆ–ç”¨æˆ¶æˆæ¬Š)', 'error');
            }
        }

        /** Encode and send a ClipboardData CursorMessage over the DataChannel */
        function sendClipboardProto(contentType, payload, hash, filenames, fileSizes) {
            const clipData = {
                content_type: contentType,
                payload: payload,
                content_hash: hash,
                filenames: filenames,
                file_sizes: fileSizes,
            };
            const msg = CursorMessage.create({
                type: 5, // MESSAGE_TYPE_CLIPBOARD
                clipboard_data: clipData,
                timestamp: Date.now(),
            });
            const buf = CursorMessage.encode(msg).finish();
            dc.send(buf);
        }

        /** Simple SHA-256 hex digest for dedup hash (mirrors blake3 on server side) */
        async function sha256hex(bytes) {
            const hashBuf = await crypto.subtle.digest('SHA-256', bytes);
            return Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2,'0')).join('');
        }

        function toggleClipAutoSync() {
            clipAutoSync = document.getElementById('clipAutoSync').checked;
            if (clipAutoSync) {
                startClipAutoSync();
            } else {
                stopClipAutoSync();
            }
        }

        function startClipAutoSync() {
            if (clipAutoSyncTimer) return;
            // Poll browser clipboard every 1 second when focused
            clipAutoSyncTimer = setInterval(async () => {
                if (!document.hasFocus()) return;
                if (!dc || dc.readyState !== 'open') return;
                await pushClipboardToHost();
            }, 1000);
            log('ğŸ”„ è‡ªå‹•å‰ªè²¼æ¿åŒæ­¥å·²å•Ÿå‹• (1 ç§’è¼ªè©¢)', 'info');
        }

        function stopClipAutoSync() {
            if (clipAutoSyncTimer) {
                clearInterval(clipAutoSyncTimer);
                clipAutoSyncTimer = null;
                log('â¹ è‡ªå‹•å‰ªè²¼æ¿åŒæ­¥å·²åœæ­¢', 'info');
            }
        }

        function clearClipboardPreview() {
            document.getElementById('clipFromHostPreview').innerHTML = '<span style="color:#aaa;">ç­‰å¾…ä¸»æ©Ÿå‰ªè²¼æ¿æ•¸æ“šâ€¦</span>';
            document.getElementById('clipFromHostMeta').textContent = '';
            document.getElementById('clipFromHostDir').style.display = 'none';
            document.getElementById('clipFileNotice').style.display = 'none';
            log('ğŸ—‘ å‰ªè²¼æ¿é è¦½å·²æ¸…é™¤', 'info');
        }

        // ========== å‹•ç•«å…‰æ¨™åŠŸèƒ½ ==========

        // Server-reported frame delay for animated cursors (ms)
        let serverFrameDelay = 0;

        function trackAnimFrame(cursorId, isAnimated, frameDelayMs) {
            const now = performance.now();

            // Use server-reported animation info for immediate detection
            if (isAnimated && frameDelayMs > 0) {
                serverFrameDelay = frameDelayMs;
            }

            // è®°å½•å¸§é—´éš”
            if (animLastChangeTime > 0) {
                const interval = now - animLastChangeTime;
                animFrameIntervals.push(interval);
                // åªä¿ç•™æœ€è¿‘ 200 ä¸ªé—´éš”
                if (animFrameIntervals.length > 200) animFrameIntervals.shift();
            }
            animLastChangeTime = now;

            animFrameSequence.push(cursorId);
            animFrameTimestamps.push(now);

            // ä¿ç•™æœ€è¿‘ 500 å¸§åºåˆ—
            if (animFrameSequence.length > 500) {
                animFrameSequence.shift();
                animFrameTimestamps.shift();
            }

            // è®°å½•å”¯ä¸€å¸§
            if (!animUniqueCursors.has(cursorId)) {
                const cached = cursorCache.get(cursorId);
                if (cached) {
                    animUniqueCursors.set(cursorId, {
                        url: cached.url,
                        width: cached.width,
                        height: cached.height,
                        hotspot_x: cached.hotspot_x,
                        hotspot_y: cached.hotspot_y
                    });
                }
            }

            detectAnimation();
            updateAnimStats();
            updateFilmstrip();
        }

        function detectAnimation() {
            // å–æœ€è¿‘ N å¸§, çœ‹å”¯ä¸€IDæ•°
            const recentWindow = 30;
            const recent = animFrameSequence.slice(-recentWindow);
            const uniqueInWindow = new Set(recent).size;

            // Server-side animation detection: if server says it's animated, trust it immediately
            if (serverFrameDelay > 0 && uniqueInWindow >= 2 && !animDetected) {
                animDetected = true;
                setAnimStatus('active', `æœåŠ¡ç«¯æ£€æµ‹åˆ°åŠ¨ç”» (${uniqueInWindow} ç§å¸§, ${serverFrameDelay}ms/å¸§)`);
                document.getElementById('animPlayPauseBtn').disabled = false;
                document.getElementById('animPlayback').style.display = 'flex';
                log('ğŸ¬ æœåŠ¡ç«¯æ£€æµ‹åˆ°åŠ¨ç”»å…‰æ ‡ï¼å¸§å»¶è¿Ÿ: ' + serverFrameDelay + 'ms, å…± ' + animUniqueCursors.size + ' ç§å”¯ä¸€å¸§', 'info');
            } else if (uniqueInWindow >= animThreshold && !animDetected) {
                animDetected = true;
                setAnimStatus('active', `æ£€æµ‹åˆ°åŠ¨ç”» (${uniqueInWindow} ç§å¸§)`);
                document.getElementById('animPlayPauseBtn').disabled = false;
                document.getElementById('animPlayback').style.display = 'flex';
                log('ğŸ¬ æ£€æµ‹åˆ°åŠ¨ç”»å…‰æ ‡ï¼å…± ' + animUniqueCursors.size + ' ç§å”¯ä¸€å¸§', 'info');
            } else if (uniqueInWindow >= 2 && !animDetected) {
                setAnimStatus('detecting', `æ£€æµ‹ä¸­ (${uniqueInWindow}/${animThreshold})`);
            }

            // å¾ªç¯æ£€æµ‹: æ‰¾é‡å¤æ¨¡å¼
            detectCycle();
        }

        function detectCycle() {
            if (animFrameSequence.length < 6) return;

            // å°è¯•ä¸åŒé•¿åº¦çš„å¾ªç¯
            for (let cycleLen = 2; cycleLen <= Math.min(30, Math.floor(animFrameSequence.length / 2)); cycleLen++) {
                const tail = animFrameSequence.slice(-cycleLen * 2);
                const first = tail.slice(0, cycleLen);
                const second = tail.slice(cycleLen);
                let match = true;
                for (let i = 0; i < cycleLen; i++) {
                    if (first[i] !== second[i]) { match = false; break; }
                }
                if (match) {
                    animCycleLength = cycleLen;
                    // è®¡ç®—å¾ªç¯æ¬¡æ•°
                    let cycles = 0;
                    outer:
                    for (let s = animFrameSequence.length - cycleLen; s >= 0; s -= cycleLen) {
                        for (let i = 0; i < cycleLen; i++) {
                            if (s + i >= animFrameSequence.length || animFrameSequence[s + i] !== first[i]) break outer;
                        }
                        cycles++;
                    }
                    animCycleCount = cycles;
                    break;
                }
            }
        }

        function setAnimStatus(state, text) {
            const el = document.getElementById('animStatus');
            el.className = 'animation-status ' + state;
            document.getElementById('animStatusText').textContent = text;
        }

        function updateAnimStats() {
            document.getElementById('animFrameCount').textContent = animFrameSequence.length;
            document.getElementById('animUniqueFrames').textContent = animUniqueCursors.size;

            // å¸§ç‡: åŸºäºæœ€è¿‘å¸§é—´éš”
            if (animFrameIntervals.length >= 2) {
                const recentIntervals = animFrameIntervals.slice(-20);
                const avgInterval = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
                const fps = avgInterval > 0 ? (1000 / avgInterval).toFixed(1) : 0;
                document.getElementById('animFps').textContent = fps;
            }

            if (animCycleLength > 0) {
                document.getElementById('animCyclePeriod').textContent = animCycleLength + ' å¸§';
                document.getElementById('animCycleCount').textContent = animCycleCount;
                document.getElementById('animCycleStatus').textContent = 'å·²æ£€æµ‹ (' + animCycleLength + 'å¸§)';
                document.getElementById('animCycleStatus').className = 'badge badge-success';
            }
        }

        function updateFilmstrip() {
            const filmstrip = document.getElementById('filmstrip');
            // åªæ˜¾ç¤ºå”¯ä¸€å¸§ (å»é‡åçš„æŒ‰é¦–æ¬¡å‡ºç°é¡ºåº)
            const seenIds = [];
            const seenSet = new Set();
            for (const id of animFrameSequence) {
                if (!seenSet.has(id)) {
                    seenSet.add(id);
                    seenIds.push(id);
                }
            }

            if (seenIds.length === 0) return;

            let html = '';
            seenIds.forEach((id, index) => {
                const info = animUniqueCursors.get(id);
                if (!info) return;
                const isActive = (animPlaying && seenIds[animPlayIndex % seenIds.length] === id) ||
                                 (!animPlaying && currentCursorId === id);
                const scale = 2;
                const dpr = info.dpi_scale || window.devicePixelRatio || 1;
                const w = Math.round((info.width || 32) / dpr * scale);
                const h = Math.round((info.height || 32) / dpr * scale);
                html += `
                    <div class="filmstrip-frame ${isActive ? 'active' : ''}" onclick="previewAnimFrame(${index})">
                        <img src="${info.url}" width="${w}" height="${h}" alt="frame ${index}">
                        <div class="frame-label">#${index + 1}</div>
                    </div>
                `;
            });
            filmstrip.innerHTML = html;

            document.getElementById('animTotalFrames').textContent = seenIds.length;
        }

        function previewAnimFrame(index) {
            const seenIds = [...new Set(animFrameSequence)];
            if (index >= seenIds.length) return;
            const id = seenIds[index];
            const info = animUniqueCursors.get(id);
            if (!info) return;

            animPlayIndex = index;
            renderAnimPreview(info, index, seenIds.length);
        }

        function renderAnimPreview(info, frameIdx, totalFrames) {
            const preview = document.getElementById('animPreview');
            const dpr = info.dpi_scale || window.devicePixelRatio || 1;
            const scale = 3;
            const w = Math.round((info.width || 32) / dpr * scale);
            const h = Math.round((info.height || 32) / dpr * scale);
            preview.innerHTML = `<img src="${info.url}" width="${w}" height="${h}" alt="preview">`;

            document.getElementById('animCurrentFrame').textContent = frameIdx + 1;

            const progress = totalFrames > 1 ? ((frameIdx) / (totalFrames - 1)) * 100 : 100;
            document.getElementById('animProgressBar').style.width = progress + '%';
        }

        function toggleAnimPlayback() {
            if (animPlaying) {
                stopAnimPlayback();
            } else {
                startAnimPlayback();
            }
        }

        function startAnimPlayback() {
            const seenIds = [...new Set(animFrameSequence)];
            if (seenIds.length < 2) return;

            animPlaying = true;
            animPlayIndex = 0;
            document.getElementById('animPlayPauseBtn').textContent = 'â¸ æš‚åœ';

            // è®¡ç®—å¸§é—´éš”: ä¼˜å…ˆä½¿ç”¨æœåŠ¡ç«¯æŠ¥å‘Šçš„å€¼
            let interval = serverFrameDelay > 0 ? serverFrameDelay : 100; // é»˜è®¤ 100ms
            if (serverFrameDelay <= 0 && animFrameIntervals.length >= 2) {
                const recentIntervals = animFrameIntervals.slice(-20);
                interval = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
            }
            interval = Math.max(16, interval / animPlaySpeed);

            animPlayTimer = setInterval(() => {
                const ids = [...new Set(animFrameSequence)];
                if (ids.length === 0) { stopAnimPlayback(); return; }
                animPlayIndex = (animPlayIndex + 1) % ids.length;
                const id = ids[animPlayIndex];
                const info = animUniqueCursors.get(id);
                if (info) {
                    renderAnimPreview(info, animPlayIndex, ids.length);
                }
                updateFilmstrip();
            }, interval);

            log('â–¶ åŠ¨ç”»æ’­æ”¾å¼€å§‹ (é—´éš”: ' + interval.toFixed(0) + 'ms)', 'info');
        }

        function stopAnimPlayback() {
            animPlaying = false;
            if (animPlayTimer) { clearInterval(animPlayTimer); animPlayTimer = null; }
            document.getElementById('animPlayPauseBtn').textContent = 'â–¶ æ’­æ”¾';
            updateFilmstrip();
            log('â¸ åŠ¨ç”»æ’­æ”¾æš‚åœ', 'info');
        }

        function updateAnimSpeed() {
            animPlaySpeed = parseFloat(document.getElementById('animSpeedSelect').value);
            if (animPlaying) {
                stopAnimPlayback();
                startAnimPlayback();
            }
            log('â© åŠ¨ç”»é€Ÿåº¦: ' + animPlaySpeed + 'x', 'info');
        }

        function updateAnimThreshold() {
            animThreshold = parseInt(document.getElementById('animThreshold').value);
            log('ğŸ¯ åŠ¨ç”»æ£€æµ‹é˜ˆå€¼: ' + animThreshold + ' å¸§', 'info');
        }

        function resetAnimFrames() {
            stopAnimPlayback();
            animFrameSequence.length = 0;
            animFrameTimestamps.length = 0;
            animFrameIntervals.length = 0;
            animUniqueCursors.clear();
            animDetected = false;
            animCycleLength = 0;
            animCycleCount = 0;
            animLastChangeTime = 0;

            setAnimStatus('idle', 'ç­‰å¾…æ£€æµ‹');
            document.getElementById('animPlayPauseBtn').disabled = true;
            document.getElementById('animPlayback').style.display = 'none';
            document.getElementById('animPreview').innerHTML = '<div class="empty-state"><div class="icon" style="font-size:32px">ğŸ–±ï¸</div></div>';
            document.getElementById('filmstrip').innerHTML = '<div class="empty-state" style="width: 100%; padding: 20px;"><div>ç­‰å¾…åŠ¨ç”»å…‰æ ‡æ•°æ®...</div></div>';
            document.getElementById('animFrameCount').textContent = '0';
            document.getElementById('animUniqueFrames').textContent = '0';
            document.getElementById('animFps').textContent = '0';
            document.getElementById('animCyclePeriod').textContent = '-';
            document.getElementById('animCycleCount').textContent = '0';
            document.getElementById('animCurrentFrame').textContent = '0';
            document.getElementById('animTotalFrames').textContent = '0';
            document.getElementById('animCycleStatus').textContent = 'æ£€æµ‹ä¸­';
            document.getElementById('animCycleStatus').className = 'badge badge-info';
            document.getElementById('animProgressBar').style.width = '0%';

            log('ğŸ—‘ åŠ¨ç”»å¸§æ•°æ®å·²æ¸…é™¤', 'info');
        }

        function captureAnimSnapshot() {
            const seenIds = [...new Set(animFrameSequence)];
            if (seenIds.length === 0) {
                log('âš ï¸ æ— å¸§æ•°æ®å¯å¿«ç…§', 'warn');
                return;
            }
            const snapshot = {
                timestamp: new Date().toISOString(),
                totalFrames: animFrameSequence.length,
                uniqueFrames: seenIds.length,
                cycleLength: animCycleLength,
                cycleCount: animCycleCount,
                avgInterval: animFrameIntervals.length > 0
                    ? (animFrameIntervals.reduce((a, b) => a + b, 0) / animFrameIntervals.length).toFixed(1) + 'ms'
                    : '-',
                sequence: animFrameSequence.slice(-50).map(id => id.substring(0, 8))
            };
            const json = JSON.stringify(snapshot, null, 2);
            console.log('Animation Snapshot:', snapshot);
            log('ğŸ“¸ å¿«ç…§å·²ä¿å­˜åˆ°æ§åˆ¶å° (å”¯ä¸€å¸§: ' + seenIds.length + ', å¾ªç¯: ' + animCycleLength + 'å¸§)', 'info');

            // ä¹Ÿå¤åˆ¶åˆ°å‰ªè´´æ¿
            navigator.clipboard.writeText(json).then(() => {
                log('ğŸ“‹ å¿«ç…§å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'info');
            }).catch(() => {});
        }
    </script>
</body>
</html>

